# 数据工程师

数据工程工具

- Hadoop
- Spark
- Python
- Scala
- Java
- C++
- SQL
- AWS/Redshift
- Azure
- Kafka

RDBMS:关系数据库管理系统

SQL:Structured Query Language

事务ACID

数据库事务的属性旨在即使在发生错误或断电时也能确保有效性。

- **原子性：**处理整个交易或不处理任何交易。通常引用的原子交易示例是两个银行帐户之间的货币交易。将钱从一个帐户转到另一个帐户的交易由两个操作组成。首先，您必须在一个帐户中提取资金，其次，您必须将提取的资金保存到第二个帐户中。原子事务（即，当所有操作都发生或什么都不发生时）使数据库保持一致状态。这样可以确保，如果这两个操作（从第一个帐户提取资金或将钱存入第二个帐户）中的任何一个失败，则既不会丢失也不会创建资金。有关此示例的详细说明，请参见[维基百科](https://en.wikipedia.org/wiki/Atomicity_(database_systems))。
- **一致性：**仅将遵守约束和规则的事务写入数据库，否则数据库将保持先前的状态。所有行和表中的数据都应该正确。在[Wikipedia](https://en.wikipedia.org/wiki/Consistency_(database_systems))上查看有关一致性的其他信息。
- **隔离：**交易独立且安全地处理，顺序无关紧要。较低的隔离度使许多用户可以同时访问数据，但是，这也增加了并发影响的可能性（例如，脏读或丢失更新）。另一方面，高级别的隔离减少了并发影响的机会，但也使用了更多的系统资源和彼此阻塞的事务。资料来源：[维基百科](https://en.wikipedia.org/wiki/Isolation_(database_systems))

- **耐用性：**即使在系统出现故障的情况下，完成的事务也会保存到数据库中。通常引用的示例包括跟踪航班座位预订。因此，一旦航班预订记录了确认的座位预订，即使发生系统故障，该座位仍会被预订。资料来源：[Wikipedia](https://en.wikipedia.org/wiki/ACID)。

### 何时不使用关系数据库

- **拥有大量数据：**关系数据库不是分布式数据库，因此，它们只能通过在计算机本身中添加更多存储来垂直扩展。一台机器上可以扩展的数量和可以存储的数据量有限。您无法像在NoSQL数据库中那样添加更多计算机。
- **需要能够存储不同的数据类型格式：**关系数据库并非旨在处理非结构化数据。
- **需要高吞吐量-快速读取：**尽管ACID事务带来了好处，但它们也减慢了读取和写入数据的过程。如果您需要非常快速的读写，则使用关系数据库可能不适合您的需求。
- **需要灵活的架构：**灵活的架构可以允许添加不必每行都使用的列，从而节省磁盘空间。
- **需要高可用性：**关系数据库不是分布式的（即使它们是分布式的，它们也具有协调器/工作人员体系结构），但它们只有一个故障点。当该数据库发生故障时，将发生故障切换到备份系统并花费时间。
- **需要水平可伸缩性：**水平可伸缩性是向系统添加更多机器或节点以增加性能和数据空间的能力。





关系数据库中的所有信息都在逻辑级别上以一种确切的方式显式表示-由表中的值表示

#### 关系数据库的特性：

- **数据模型的标准化：**将数据转换为行和列格式后，数据就已经标准化，您可以使用SQL查询它
- **添加和更改表的灵活性：**关系数据库使您可以灵活地添加表，更改表，添加和删除数据。
- **数据完整性：**数据完整性是使用关系数据库的基础。
- **结构化查询语言（SQL）：**可以使用标准语言以预定义的语言访问数据。
- **简便性：**数据以表格格式系统存储和建模。
- **直观的组织：**电子表格格式是直观的，但是对于关系数据库中的数据建模来说是直观的。

**在线分析处理（OLAP）：**
针对这些工作负载进行了优化的数据库允许进行复杂的分析和临时查询，包括聚合。这些类型的数据库针对读取进行了优化。

**在线事务处理（OLTP）：**
针对这些工作负载进行了优化的数据库允许进行大容量的不太复杂的查询。这些数据库的查询类型为读取，插入，更新和删除。

 **OLTP查询实际上几乎没有聚合，而OLAP则将重点放在聚合上**

关系型数据库设计：

**第一范式（1NF）：**

- 原子值：每个单元格包含唯一值和单个值
- 能够添加数据而不更改表
- 将不同的关系分为不同的表
- 保持表之间的关系以及外键

**第二范式（2NF）：**

- 已达到1NF
- 表中的所有列都必须依赖主键

**第三范式（3NF）：**

- 必须为第二范式
- 没有传递依赖
- 请记住，您要维护的可传递依赖关系是要从A-> C获得，您要避免通过B。

**非规范化：**

数据库上的JOINS具有出色的灵活性，但是速度非常慢。如果要处理数据库上的大量读取，则可能需要考虑对表进行非规范化。您将数据转换为标准化形式，然后继续进行非标准化。因此，非规范化是在规范化之后进行的。 	

**规范化**是通过减少数据副本的数量来尝试提高数据完整性。需要添加或更新的数据将在尽可能少的地方完成。

**非规范化**试图通过减少表之间的联接数来提高性能（因为联接可能很慢）。数据完整性会受到一些潜在的打击，因为将会有更多的数据副本（以减少JOINS）。

**实体关系图**（ERD）以简洁易懂的方式显示数据模型。ERD可以用于任何数据模型，并且不限于STAR或SNOWFLAKE模式。常用工具可用于生成ERD。

**星形模式**是[数据集市](https://en.wikipedia.org/wiki/Data_mart) [模式](https://en.wikipedia.org/wiki/Logical_schema)的最简单样式，并且是最广泛用于开发数据仓库和维度数据集市的方法，星型模式由一个或多个[事实表](https://en.wikipedia.org/wiki/Fact_table)组成，该[事实表](https://en.wikipedia.org/wiki/Fact_table)引用了任意数量的[维表](https://en.wikipedia.org/wiki/Dimension_(data_warehouse))。星型模式是[雪花模式](https://en.wikipedia.org/wiki/Snowflake_schema)的重要特例，对于处理更简单的查询更有效

星型模式好处：1. 可以对表格进行非规范化，2.简化查询，3.快速的数据统计；缺点：1.数据完整性和降低查询灵活性 2.不能处理多对多关系

**雪花模式**是[多维数据库](https://en.wikipedia.org/wiki/Multidimensional_database)中表的[逻辑排列](https://en.wikipedia.org/wiki/Logical_schema)，以使[实体关系](https://en.wikipedia.org/wiki/Entity-relationship_model)图类似于[雪花](https://en.wikipedia.org/wiki/Snowflake) 形状。雪花模式由连接到多个[维度的](https://en.wikipedia.org/wiki/Dimension_(data_warehouse))集中[事实表](https://en.wikipedia.org/wiki/Fact_table)表示，“雪花化”是一种在[星型模式](https://en.wikipedia.org/wiki/Star_schema)中标准化维度表的方法。当所有维度表都完全归一化后，结果结构类似于带有[事实表](https://en.wikipedia.org/wiki/Fact_table)的雪花在中间。雪花背后的原理是通过删除低基数属性并形成单独的表来规范维表